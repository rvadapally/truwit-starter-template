{"ast":null,"code":"import _asyncToGenerator from \"C:/HareKrishna/Raghu/Truwit/humanproof-starter/web/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nfunction e(e, t) {\n  var o = {};\n  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (o[n] = e[n]);\n  if (null != e && \"function\" == typeof Object.getOwnPropertySymbols) {\n    var i = 0;\n    for (n = Object.getOwnPropertySymbols(e); i < n.length; i++) t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (o[n[i]] = e[n[i]]);\n  }\n  return o;\n}\n\"function\" == typeof SuppressedError && SuppressedError;\nvar t = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {};\nfunction o(e) {\n  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n}\nfunction n(e, t) {\n  return e(t = {\n    exports: {}\n  }, t.exports), t.exports;\n}\nvar i = n(function (e, t) {\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n  var o = function () {\n    function e() {\n      var e = this;\n      this.locked = new Map(), this.addToLocked = function (t, o) {\n        var n = e.locked.get(t);\n        void 0 === n ? void 0 === o ? e.locked.set(t, []) : e.locked.set(t, [o]) : void 0 !== o && (n.unshift(o), e.locked.set(t, n));\n      }, this.isLocked = function (t) {\n        return e.locked.has(t);\n      }, this.lock = function (t) {\n        return new Promise(function (o, n) {\n          e.isLocked(t) ? e.addToLocked(t, o) : (e.addToLocked(t), o());\n        });\n      }, this.unlock = function (t) {\n        var o = e.locked.get(t);\n        if (void 0 !== o && 0 !== o.length) {\n          var n = o.pop();\n          e.locked.set(t, o), void 0 !== n && setTimeout(n, 0);\n        } else e.locked.delete(t);\n      };\n    }\n    return e.getInstance = function () {\n      return void 0 === e.instance && (e.instance = new e()), e.instance;\n    }, e;\n  }();\n  t.default = function () {\n    return o.getInstance();\n  };\n});\no(i);\nvar r = o(n(function (e, o) {\n  var n = t && t.__awaiter || function (e, t, o, n) {\n      return new (o || (o = Promise))(function (i, r) {\n        function s(e) {\n          try {\n            c(n.next(e));\n          } catch (e) {\n            r(e);\n          }\n        }\n        function a(e) {\n          try {\n            c(n.throw(e));\n          } catch (e) {\n            r(e);\n          }\n        }\n        function c(e) {\n          e.done ? i(e.value) : new o(function (t) {\n            t(e.value);\n          }).then(s, a);\n        }\n        c((n = n.apply(e, t || [])).next());\n      });\n    },\n    r = t && t.__generator || function (e, t) {\n      var o,\n        n,\n        i,\n        r,\n        s = {\n          label: 0,\n          sent: function () {\n            if (1 & i[0]) throw i[1];\n            return i[1];\n          },\n          trys: [],\n          ops: []\n        };\n      return r = {\n        next: a(0),\n        throw: a(1),\n        return: a(2)\n      }, \"function\" == typeof Symbol && (r[Symbol.iterator] = function () {\n        return this;\n      }), r;\n      function a(r) {\n        return function (a) {\n          return function (r) {\n            if (o) throw new TypeError(\"Generator is already executing.\");\n            for (; s;) try {\n              if (o = 1, n && (i = 2 & r[0] ? n.return : r[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, r[1])).done) return i;\n              switch (n = 0, i && (r = [2 & r[0], i.value]), r[0]) {\n                case 0:\n                case 1:\n                  i = r;\n                  break;\n                case 4:\n                  return s.label++, {\n                    value: r[1],\n                    done: !1\n                  };\n                case 5:\n                  s.label++, n = r[1], r = [0];\n                  continue;\n                case 7:\n                  r = s.ops.pop(), s.trys.pop();\n                  continue;\n                default:\n                  if (!(i = s.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== r[0] && 2 !== r[0])) {\n                    s = 0;\n                    continue;\n                  }\n                  if (3 === r[0] && (!i || r[1] > i[0] && r[1] < i[3])) {\n                    s.label = r[1];\n                    break;\n                  }\n                  if (6 === r[0] && s.label < i[1]) {\n                    s.label = i[1], i = r;\n                    break;\n                  }\n                  if (i && s.label < i[2]) {\n                    s.label = i[2], s.ops.push(r);\n                    break;\n                  }\n                  i[2] && s.ops.pop(), s.trys.pop();\n                  continue;\n              }\n              r = t.call(e, s);\n            } catch (e) {\n              r = [6, e], n = 0;\n            } finally {\n              o = i = 0;\n            }\n            if (5 & r[0]) throw r[1];\n            return {\n              value: r[0] ? r[1] : void 0,\n              done: !0\n            };\n          }([r, a]);\n        };\n      }\n    },\n    s = t;\n  Object.defineProperty(o, \"__esModule\", {\n    value: !0\n  });\n  var a = \"browser-tabs-lock-key\",\n    c = {\n      key: function (e) {\n        return n(s, void 0, void 0, function () {\n          return r(this, function (e) {\n            throw new Error(\"Unsupported\");\n          });\n        });\n      },\n      getItem: function (e) {\n        return n(s, void 0, void 0, function () {\n          return r(this, function (e) {\n            throw new Error(\"Unsupported\");\n          });\n        });\n      },\n      clear: function () {\n        return n(s, void 0, void 0, function () {\n          return r(this, function (e) {\n            return [2, window.localStorage.clear()];\n          });\n        });\n      },\n      removeItem: function (e) {\n        return n(s, void 0, void 0, function () {\n          return r(this, function (e) {\n            throw new Error(\"Unsupported\");\n          });\n        });\n      },\n      setItem: function (e, t) {\n        return n(s, void 0, void 0, function () {\n          return r(this, function (e) {\n            throw new Error(\"Unsupported\");\n          });\n        });\n      },\n      keySync: function (e) {\n        return window.localStorage.key(e);\n      },\n      getItemSync: function (e) {\n        return window.localStorage.getItem(e);\n      },\n      clearSync: function () {\n        return window.localStorage.clear();\n      },\n      removeItemSync: function (e) {\n        return window.localStorage.removeItem(e);\n      },\n      setItemSync: function (e, t) {\n        return window.localStorage.setItem(e, t);\n      }\n    };\n  function u(e) {\n    return new Promise(function (t) {\n      return setTimeout(t, e);\n    });\n  }\n  function h(e) {\n    for (var t = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\", o = \"\", n = 0; n < e; n++) {\n      o += t[Math.floor(Math.random() * t.length)];\n    }\n    return o;\n  }\n  var d = function () {\n    function e(t) {\n      this.acquiredIatSet = new Set(), this.storageHandler = void 0, this.id = Date.now().toString() + h(15), this.acquireLock = this.acquireLock.bind(this), this.releaseLock = this.releaseLock.bind(this), this.releaseLock__private__ = this.releaseLock__private__.bind(this), this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this), this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this), this.storageHandler = t, void 0 === e.waiters && (e.waiters = []);\n    }\n    return e.prototype.acquireLock = function (t, o) {\n      return void 0 === o && (o = 5e3), n(this, void 0, void 0, function () {\n        var n, i, s, d, l, p, m;\n        return r(this, function (r) {\n          switch (r.label) {\n            case 0:\n              n = Date.now() + h(4), i = Date.now() + o, s = a + \"-\" + t, d = void 0 === this.storageHandler ? c : this.storageHandler, r.label = 1;\n            case 1:\n              return Date.now() < i ? [4, u(30)] : [3, 8];\n            case 2:\n              return r.sent(), null !== d.getItemSync(s) ? [3, 5] : (l = this.id + \"-\" + t + \"-\" + n, [4, u(Math.floor(25 * Math.random()))]);\n            case 3:\n              return r.sent(), d.setItemSync(s, JSON.stringify({\n                id: this.id,\n                iat: n,\n                timeoutKey: l,\n                timeAcquired: Date.now(),\n                timeRefreshed: Date.now()\n              })), [4, u(30)];\n            case 4:\n              return r.sent(), null !== (p = d.getItemSync(s)) && (m = JSON.parse(p)).id === this.id && m.iat === n ? (this.acquiredIatSet.add(n), this.refreshLockWhileAcquired(s, n), [2, !0]) : [3, 7];\n            case 5:\n              return e.lockCorrector(void 0 === this.storageHandler ? c : this.storageHandler), [4, this.waitForSomethingToChange(i)];\n            case 6:\n              r.sent(), r.label = 7;\n            case 7:\n              return n = Date.now() + h(4), [3, 1];\n            case 8:\n              return [2, !1];\n          }\n        });\n      });\n    }, e.prototype.refreshLockWhileAcquired = function (e, t) {\n      return n(this, void 0, void 0, function () {\n        var o = this;\n        return r(this, function (s) {\n          return setTimeout(function () {\n            return n(o, void 0, void 0, function () {\n              var o, n, s;\n              return r(this, function (r) {\n                switch (r.label) {\n                  case 0:\n                    return [4, i.default().lock(t)];\n                  case 1:\n                    return r.sent(), this.acquiredIatSet.has(t) ? (o = void 0 === this.storageHandler ? c : this.storageHandler, null === (n = o.getItemSync(e)) ? (i.default().unlock(t), [2]) : ((s = JSON.parse(n)).timeRefreshed = Date.now(), o.setItemSync(e, JSON.stringify(s)), i.default().unlock(t), this.refreshLockWhileAcquired(e, t), [2])) : (i.default().unlock(t), [2]);\n                }\n              });\n            });\n          }, 1e3), [2];\n        });\n      });\n    }, e.prototype.waitForSomethingToChange = function (t) {\n      return n(this, void 0, void 0, function () {\n        return r(this, function (o) {\n          switch (o.label) {\n            case 0:\n              return [4, new Promise(function (o) {\n                var n = !1,\n                  i = Date.now(),\n                  r = !1;\n                function s() {\n                  if (r || (window.removeEventListener(\"storage\", s), e.removeFromWaiting(s), clearTimeout(a), r = !0), !n) {\n                    n = !0;\n                    var t = 50 - (Date.now() - i);\n                    t > 0 ? setTimeout(o, t) : o(null);\n                  }\n                }\n                window.addEventListener(\"storage\", s), e.addToWaiting(s);\n                var a = setTimeout(s, Math.max(0, t - Date.now()));\n              })];\n            case 1:\n              return o.sent(), [2];\n          }\n        });\n      });\n    }, e.addToWaiting = function (t) {\n      this.removeFromWaiting(t), void 0 !== e.waiters && e.waiters.push(t);\n    }, e.removeFromWaiting = function (t) {\n      void 0 !== e.waiters && (e.waiters = e.waiters.filter(function (e) {\n        return e !== t;\n      }));\n    }, e.notifyWaiters = function () {\n      void 0 !== e.waiters && e.waiters.slice().forEach(function (e) {\n        return e();\n      });\n    }, e.prototype.releaseLock = function (e) {\n      return n(this, void 0, void 0, function () {\n        return r(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return [4, this.releaseLock__private__(e)];\n            case 1:\n              return [2, t.sent()];\n          }\n        });\n      });\n    }, e.prototype.releaseLock__private__ = function (t) {\n      return n(this, void 0, void 0, function () {\n        var o, n, s, u;\n        return r(this, function (r) {\n          switch (r.label) {\n            case 0:\n              return o = void 0 === this.storageHandler ? c : this.storageHandler, n = a + \"-\" + t, null === (s = o.getItemSync(n)) ? [2] : (u = JSON.parse(s)).id !== this.id ? [3, 2] : [4, i.default().lock(u.iat)];\n            case 1:\n              r.sent(), this.acquiredIatSet.delete(u.iat), o.removeItemSync(n), i.default().unlock(u.iat), e.notifyWaiters(), r.label = 2;\n            case 2:\n              return [2];\n          }\n        });\n      });\n    }, e.lockCorrector = function (t) {\n      for (var o = Date.now() - 5e3, n = t, i = [], r = 0;;) {\n        var s = n.keySync(r);\n        if (null === s) break;\n        i.push(s), r++;\n      }\n      for (var c = !1, u = 0; u < i.length; u++) {\n        var h = i[u];\n        if (h.includes(a)) {\n          var d = n.getItemSync(h);\n          if (null !== d) {\n            var l = JSON.parse(d);\n            (void 0 === l.timeRefreshed && l.timeAcquired < o || void 0 !== l.timeRefreshed && l.timeRefreshed < o) && (n.removeItemSync(h), c = !0);\n          }\n        }\n      }\n      c && e.notifyWaiters();\n    }, e.waiters = void 0, e;\n  }();\n  o.default = d;\n}));\nconst s = {\n    timeoutInSeconds: 60\n  },\n  a = {\n    name: \"auth0-spa-js\",\n    version: \"2.5.0\"\n  },\n  c = () => Date.now();\nclass u extends Error {\n  constructor(e, t) {\n    super(t), this.error = e, this.error_description = t, Object.setPrototypeOf(this, u.prototype);\n  }\n  static fromPayload({\n    error: e,\n    error_description: t\n  }) {\n    return new u(e, t);\n  }\n}\nclass h extends u {\n  constructor(e, t, o, n = null) {\n    super(e, t), this.state = o, this.appState = n, Object.setPrototypeOf(this, h.prototype);\n  }\n}\nclass d extends u {\n  constructor() {\n    super(\"timeout\", \"Timeout\"), Object.setPrototypeOf(this, d.prototype);\n  }\n}\nclass l extends d {\n  constructor(e) {\n    super(), this.popup = e, Object.setPrototypeOf(this, l.prototype);\n  }\n}\nclass p extends u {\n  constructor(e) {\n    super(\"cancelled\", \"Popup closed\"), this.popup = e, Object.setPrototypeOf(this, p.prototype);\n  }\n}\nclass m extends u {\n  constructor(e, t, o) {\n    super(e, t), this.mfa_token = o, Object.setPrototypeOf(this, m.prototype);\n  }\n}\nclass f extends u {\n  constructor(e, t) {\n    super(\"missing_refresh_token\", `Missing Refresh Token (audience: '${y(e, [\"default\"])}', scope: '${y(t)}')`), this.audience = e, this.scope = t, Object.setPrototypeOf(this, f.prototype);\n  }\n}\nclass g extends u {\n  constructor(e) {\n    super(\"use_dpop_nonce\", \"Server rejected DPoP proof: wrong nonce\"), this.newDpopNonce = e, Object.setPrototypeOf(this, g.prototype);\n  }\n}\nfunction y(e, t = []) {\n  return e && !t.includes(e) ? e : \"\";\n}\nconst w = () => window.crypto,\n  b = () => {\n    const e = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.\";\n    let t = \"\";\n    return Array.from(w().getRandomValues(new Uint8Array(43))).forEach(o => t += e[o % e.length]), t;\n  },\n  k = e => btoa(e),\n  v = t => {\n    var {\n        clientId: o\n      } = t,\n      n = e(t, [\"clientId\"]);\n    return new URLSearchParams((e => Object.keys(e).filter(t => void 0 !== e[t]).reduce((t, o) => Object.assign(Object.assign({}, t), {\n      [o]: e[o]\n    }), {}))(Object.assign({\n      client_id: o\n    }, n))).toString();\n  },\n  _ = e => (e => decodeURIComponent(atob(e).split(\"\").map(e => \"%\" + (\"00\" + e.charCodeAt(0).toString(16)).slice(-2)).join(\"\")))(e.replace(/_/g, \"/\").replace(/-/g, \"+\")),\n  I = new TextEncoder(),\n  S = new TextDecoder();\nfunction T(e) {\n  return \"string\" == typeof e ? I.encode(e) : S.decode(e);\n}\nfunction P(e) {\n  if (\"number\" != typeof e.modulusLength || e.modulusLength < 2048) throw new C(`${e.name} modulusLength must be at least 2048 bits`);\n}\nfunction O(_x, _x2, _x3) {\n  return _O.apply(this, arguments);\n}\nfunction _O() {\n  _O = _asyncToGenerator(function* (e, t, o) {\n    if (!1 === o.usages.includes(\"sign\")) throw new TypeError('private CryptoKey instances used for signing assertions must include \"sign\" in their \"usages\"');\n    const n = `${x(T(JSON.stringify(e)))}.${x(T(JSON.stringify(t)))}`;\n    return `${n}.${x(yield crypto.subtle.sign(function (e) {\n      switch (e.algorithm.name) {\n        case \"ECDSA\":\n          return {\n            name: e.algorithm.name,\n            hash: \"SHA-256\"\n          };\n        case \"RSA-PSS\":\n          return P(e.algorithm), {\n            name: e.algorithm.name,\n            saltLength: 32\n          };\n        case \"RSASSA-PKCS1-v1_5\":\n          return P(e.algorithm), {\n            name: e.algorithm.name\n          };\n        case \"Ed25519\":\n          return {\n            name: e.algorithm.name\n          };\n      }\n      throw new K();\n    }(o), o, T(n)))}`;\n  });\n  return _O.apply(this, arguments);\n}\nlet j;\nif (Uint8Array.prototype.toBase64) j = e => (e instanceof ArrayBuffer && (e = new Uint8Array(e)), e.toBase64({\n  alphabet: \"base64url\",\n  omitPadding: !0\n}));else {\n  const e = 32768;\n  j = t => {\n    t instanceof ArrayBuffer && (t = new Uint8Array(t));\n    const o = [];\n    for (let n = 0; n < t.byteLength; n += e) o.push(String.fromCharCode.apply(null, t.subarray(n, n + e)));\n    return btoa(o.join(\"\")).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n  };\n}\nfunction x(e) {\n  return j(e);\n}\nclass K extends Error {\n  constructor(e) {\n    var t;\n    super(null != e ? e : \"operation not supported\"), this.name = this.constructor.name, null === (t = Error.captureStackTrace) || void 0 === t || t.call(Error, this, this.constructor);\n  }\n}\nclass C extends Error {\n  constructor(e) {\n    var t;\n    super(e), this.name = this.constructor.name, null === (t = Error.captureStackTrace) || void 0 === t || t.call(Error, this, this.constructor);\n  }\n}\nfunction E(e) {\n  switch (e.algorithm.name) {\n    case \"RSA-PSS\":\n      return function (e) {\n        if (\"SHA-256\" === e.algorithm.hash.name) return \"PS256\";\n        throw new K(\"unsupported RsaHashedKeyAlgorithm hash name\");\n      }(e);\n    case \"RSASSA-PKCS1-v1_5\":\n      return function (e) {\n        if (\"SHA-256\" === e.algorithm.hash.name) return \"RS256\";\n        throw new K(\"unsupported RsaHashedKeyAlgorithm hash name\");\n      }(e);\n    case \"ECDSA\":\n      return function (e) {\n        if (\"P-256\" === e.algorithm.namedCurve) return \"ES256\";\n        throw new K(\"unsupported EcKeyAlgorithm namedCurve\");\n      }(e);\n    case \"Ed25519\":\n      return \"Ed25519\";\n    default:\n      throw new K(\"unsupported CryptoKey algorithm name\");\n  }\n}\nfunction z(e) {\n  return e instanceof CryptoKey;\n}\nfunction N(e) {\n  return z(e) && \"public\" === e.type;\n}\nfunction D(_x4, _x5, _x6, _x7, _x8, _x9) {\n  return _D.apply(this, arguments);\n}\nfunction _D() {\n  _D = _asyncToGenerator(function* (e, t, o, n, i, r) {\n    const s = null == e ? void 0 : e.privateKey,\n      a = null == e ? void 0 : e.publicKey;\n    if (!z(c = s) || \"private\" !== c.type) throw new TypeError('\"keypair.privateKey\" must be a private CryptoKey');\n    var c;\n    if (!N(a)) throw new TypeError('\"keypair.publicKey\" must be a public CryptoKey');\n    if (!0 !== a.extractable) throw new TypeError('\"keypair.publicKey.extractable\" must be true');\n    if (\"string\" != typeof t) throw new TypeError('\"htu\" must be a string');\n    if (\"string\" != typeof o) throw new TypeError('\"htm\" must be a string');\n    if (void 0 !== n && \"string\" != typeof n) throw new TypeError('\"nonce\" must be a string or undefined');\n    if (void 0 !== i && \"string\" != typeof i) throw new TypeError('\"accessToken\" must be a string or undefined');\n    if (void 0 !== r && (\"object\" != typeof r || null === r || Array.isArray(r))) throw new TypeError('\"additional\" must be an object');\n    return O({\n      alg: E(s),\n      typ: \"dpop+jwt\",\n      jwk: yield Z(a)\n    }, Object.assign(Object.assign({}, r), {\n      iat: Math.floor(Date.now() / 1e3),\n      jti: crypto.randomUUID(),\n      htm: o,\n      nonce: n,\n      htu: t,\n      ath: i ? x(yield crypto.subtle.digest(\"SHA-256\", T(i))) : void 0\n    }), s);\n  });\n  return _D.apply(this, arguments);\n}\nfunction Z(_x0) {\n  return _Z.apply(this, arguments);\n}\nfunction _Z() {\n  _Z = _asyncToGenerator(function* (e) {\n    const {\n      kty: t,\n      e: o,\n      n: n,\n      x: i,\n      y: r,\n      crv: s\n    } = yield crypto.subtle.exportKey(\"jwk\", e);\n    return {\n      kty: t,\n      crv: s,\n      e: o,\n      n: n,\n      x: i,\n      y: r\n    };\n  });\n  return _Z.apply(this, arguments);\n}\nconst R = [\"authorization_code\", \"refresh_token\", \"urn:ietf:params:oauth:grant-type:token-exchange\"];\nfunction U() {\n  return function () {\n    var _ref = _asyncToGenerator(function* (e, t) {\n      var o;\n      let n;\n      if (\"string\" != typeof e || 0 === e.length) throw new TypeError('\"alg\" must be a non-empty string');\n      switch (e) {\n        case \"PS256\":\n          n = {\n            name: \"RSA-PSS\",\n            hash: \"SHA-256\",\n            modulusLength: 2048,\n            publicExponent: new Uint8Array([1, 0, 1])\n          };\n          break;\n        case \"RS256\":\n          n = {\n            name: \"RSASSA-PKCS1-v1_5\",\n            hash: \"SHA-256\",\n            modulusLength: 2048,\n            publicExponent: new Uint8Array([1, 0, 1])\n          };\n          break;\n        case \"ES256\":\n          n = {\n            name: \"ECDSA\",\n            namedCurve: \"P-256\"\n          };\n          break;\n        case \"Ed25519\":\n          n = {\n            name: \"Ed25519\"\n          };\n          break;\n        default:\n          throw new K();\n      }\n      return crypto.subtle.generateKey(n, null !== (o = null == t ? void 0 : t.extractable) && void 0 !== o && o, [\"sign\", \"verify\"]);\n    });\n    return function (_x1, _x10) {\n      return _ref.apply(this, arguments);\n    };\n  }()(\"ES256\", {\n    extractable: !1\n  });\n}\nfunction L(e) {\n  return function () {\n    var _ref2 = _asyncToGenerator(function* (e) {\n      if (!N(e)) throw new TypeError('\"publicKey\" must be a public CryptoKey');\n      if (!0 !== e.extractable) throw new TypeError('\"publicKey.extractable\" must be true');\n      const t = yield Z(e);\n      let o;\n      switch (t.kty) {\n        case \"EC\":\n          o = {\n            crv: t.crv,\n            kty: t.kty,\n            x: t.x,\n            y: t.y\n          };\n          break;\n        case \"OKP\":\n          o = {\n            crv: t.crv,\n            kty: t.kty,\n            x: t.x\n          };\n          break;\n        case \"RSA\":\n          o = {\n            e: t.e,\n            kty: t.kty,\n            n: t.n\n          };\n          break;\n        default:\n          throw new K(\"unsupported JWK kty\");\n      }\n      return x(yield crypto.subtle.digest({\n        name: \"SHA-256\"\n      }, T(JSON.stringify(o))));\n    });\n    return function (_x11) {\n      return _ref2.apply(this, arguments);\n    };\n  }()(e.publicKey);\n}\nfunction W({\n  keyPair: e,\n  url: t,\n  method: o,\n  nonce: n,\n  accessToken: i\n}) {\n  const r = function (e) {\n    const t = new URL(e);\n    return t.search = \"\", t.hash = \"\", t.href;\n  }(t);\n  return D(e, r, o, n, i);\n}\nconst H = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator(function* (e, t) {\n      const o = yield fetch(e, t);\n      return {\n        ok: o.ok,\n        json: yield o.json(),\n        headers: (n = o.headers, [...n].reduce((e, [t, o]) => (e[t] = o, e), {}))\n      };\n      var n;\n    });\n    return function H(_x12, _x13) {\n      return _ref3.apply(this, arguments);\n    };\n  }(),\n  A = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator(function* (e, t, o) {\n      const n = new AbortController();\n      let i;\n      return t.signal = n.signal, Promise.race([H(e, t), new Promise((e, t) => {\n        i = setTimeout(() => {\n          n.abort(), t(new Error(\"Timeout when executing 'fetch'\"));\n        }, o);\n      })]).finally(() => {\n        clearTimeout(i);\n      });\n    });\n    return function A(_x14, _x15, _x16) {\n      return _ref4.apply(this, arguments);\n    };\n  }(),\n  J = /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator(function* (e, t, o, n, i, r, s, a) {\n      return c = {\n        auth: {\n          audience: t,\n          scope: o\n        },\n        timeout: i,\n        fetchUrl: e,\n        fetchOptions: n,\n        useFormData: s,\n        useMrrt: a\n      }, u = r, new Promise(function (e, t) {\n        const o = new MessageChannel();\n        o.port1.onmessage = function (n) {\n          n.data.error ? t(new Error(n.data.error)) : e(n.data), o.port1.close();\n        }, u.postMessage(c, [o.port2]);\n      });\n      var c, u;\n    });\n    return function J(_x17, _x18, _x19, _x20, _x21, _x22, _x23, _x24) {\n      return _ref5.apply(this, arguments);\n    };\n  }(),\n  X = /*#__PURE__*/function () {\n    var _ref6 = _asyncToGenerator(function* (e, t, o, n, i, r, s = 1e4, a) {\n      return i ? J(e, t, o, n, s, i, r, a) : A(e, n, s);\n    });\n    return function X(_x25, _x26, _x27, _x28, _x29, _x30) {\n      return _ref6.apply(this, arguments);\n    };\n  }();\nfunction V(_x31, _x32, _x33, _x34, _x35, _x36, _x37, _x38, _x39, _x40) {\n  return _V.apply(this, arguments);\n}\nfunction _V() {\n  _V = _asyncToGenerator(function* (t, o, n, i, r, s, a, c, h, d) {\n    if (h) {\n      const e = yield h.generateProof({\n        url: t,\n        method: r.method || \"GET\",\n        nonce: yield h.getNonce()\n      });\n      r.headers = Object.assign(Object.assign({}, r.headers), {\n        dpop: e\n      });\n    }\n    let l,\n      p = null;\n    for (let e = 0; e < 3; e++) try {\n      l = yield X(t, n, i, r, s, a, o, c), p = null;\n      break;\n    } catch (e) {\n      p = e;\n    }\n    if (p) throw p;\n    const y = l.json,\n      {\n        error: w,\n        error_description: b\n      } = y,\n      k = e(y, [\"error\", \"error_description\"]),\n      {\n        headers: v,\n        ok: _\n      } = l;\n    let I;\n    if (h && (I = v[\"dpop-nonce\"], I && (yield h.setNonce(I))), !_) {\n      const e = b || `HTTP error. Unable to fetch ${t}`;\n      if (\"mfa_required\" === w) throw new m(w, e, k.mfa_token);\n      if (\"missing_refresh_token\" === w) throw new f(n, i);\n      if (\"use_dpop_nonce\" === w) {\n        if (!h || !I || d) throw new g(I);\n        return V(t, o, n, i, r, s, a, c, h, !0);\n      }\n      throw new u(w || \"request_error\", e);\n    }\n    return k;\n  });\n  return _V.apply(this, arguments);\n}\nfunction G(_x41, _x42) {\n  return _G.apply(this, arguments);\n}\nfunction _G() {\n  _G = _asyncToGenerator(function* (t, o) {\n    var {\n        baseUrl: n,\n        timeout: i,\n        audience: r,\n        scope: s,\n        auth0Client: c,\n        useFormData: u,\n        useMrrt: h,\n        dpop: d\n      } = t,\n      l = e(t, [\"baseUrl\", \"timeout\", \"audience\", \"scope\", \"auth0Client\", \"useFormData\", \"useMrrt\", \"dpop\"]);\n    const p = \"urn:ietf:params:oauth:grant-type:token-exchange\" === l.grant_type,\n      m = \"refresh_token\" === l.grant_type && h,\n      f = Object.assign(Object.assign(Object.assign(Object.assign({}, l), p && r && {\n        audience: r\n      }), p && s && {\n        scope: s\n      }), m && {\n        audience: r,\n        scope: s\n      }),\n      g = u ? v(f) : JSON.stringify(f),\n      y = (w = l.grant_type, R.includes(w));\n    var w;\n    return yield V(`${n}/oauth/token`, i, r || \"default\", s, {\n      method: \"POST\",\n      body: g,\n      headers: {\n        \"Content-Type\": u ? \"application/x-www-form-urlencoded\" : \"application/json\",\n        \"Auth0-Client\": btoa(JSON.stringify(c || a))\n      }\n    }, o, u, h, y ? d : void 0);\n  });\n  return _G.apply(this, arguments);\n}\nconst F = (...e) => {\n  return (t = e.filter(Boolean).join(\" \").trim().split(/\\s+/), Array.from(new Set(t))).join(\" \");\n  var t;\n};\nclass M {\n  constructor(e, t = \"@@auth0spajs@@\", o) {\n    this.prefix = t, this.suffix = o, this.clientId = e.clientId, this.scope = e.scope, this.audience = e.audience;\n  }\n  toKey() {\n    return [this.prefix, this.clientId, this.audience, this.scope, this.suffix].filter(Boolean).join(\"::\");\n  }\n  static fromKey(e) {\n    const [t, o, n, i] = e.split(\"::\");\n    return new M({\n      clientId: o,\n      scope: i,\n      audience: n\n    }, t);\n  }\n  static fromCacheEntry(e) {\n    const {\n      scope: t,\n      audience: o,\n      client_id: n\n    } = e;\n    return new M({\n      scope: t,\n      audience: o,\n      clientId: n\n    });\n  }\n}\nclass Y {\n  set(e, t) {\n    localStorage.setItem(e, JSON.stringify(t));\n  }\n  get(e) {\n    const t = window.localStorage.getItem(e);\n    if (t) try {\n      return JSON.parse(t);\n    } catch (e) {\n      return;\n    }\n  }\n  remove(e) {\n    localStorage.removeItem(e);\n  }\n  allKeys() {\n    return Object.keys(window.localStorage).filter(e => e.startsWith(\"@@auth0spajs@@\"));\n  }\n}\nclass $ {\n  constructor() {\n    this.enclosedCache = function () {\n      let e = {};\n      return {\n        set(t, o) {\n          e[t] = o;\n        },\n        get(t) {\n          const o = e[t];\n          if (o) return o;\n        },\n        remove(t) {\n          delete e[t];\n        },\n        allKeys: () => Object.keys(e)\n      };\n    }();\n  }\n}\nclass B {\n  constructor(e, t, o) {\n    this.cache = e, this.keyManifest = t, this.nowProvider = o || c;\n  }\n  setIdToken(e, t, o) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      var n;\n      const i = _this.getIdTokenCacheKey(e);\n      yield _this.cache.set(i, {\n        id_token: t,\n        decodedToken: o\n      }), yield null === (n = _this.keyManifest) || void 0 === n ? void 0 : n.add(i);\n    })();\n  }\n  getIdToken(e) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const t = yield _this2.cache.get(_this2.getIdTokenCacheKey(e.clientId));\n      if (!t && e.scope && e.audience) {\n        const t = yield _this2.get(e);\n        if (!t) return;\n        if (!t.id_token || !t.decodedToken) return;\n        return {\n          id_token: t.id_token,\n          decodedToken: t.decodedToken\n        };\n      }\n      if (t) return {\n        id_token: t.id_token,\n        decodedToken: t.decodedToken\n      };\n    })();\n  }\n  get(_x43) {\n    var _this3 = this;\n    return _asyncToGenerator(function* (e, t = 0, o = !1, n) {\n      var i;\n      let r = yield _this3.cache.get(e.toKey());\n      if (!r) {\n        const t = yield _this3.getCacheKeys();\n        if (!t) return;\n        const i = _this3.matchExistingCacheKey(e, t);\n        if (i && (r = yield _this3.cache.get(i)), !i && o && \"cache-only\" !== n) return _this3.getEntryWithRefreshToken(e, t);\n      }\n      if (!r) return;\n      const s = yield _this3.nowProvider(),\n        a = Math.floor(s / 1e3);\n      return r.expiresAt - t < a ? r.body.refresh_token ? _this3.modifiedCachedEntry(r, e) : (yield _this3.cache.remove(e.toKey()), void (yield null === (i = _this3.keyManifest) || void 0 === i ? void 0 : i.remove(e.toKey()))) : r.body;\n    }).apply(this, arguments);\n  }\n  modifiedCachedEntry(e, t) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return e.body = {\n        refresh_token: e.body.refresh_token,\n        audience: e.body.audience,\n        scope: e.body.scope\n      }, yield _this4.cache.set(t.toKey(), e), {\n        refresh_token: e.body.refresh_token,\n        audience: e.body.audience,\n        scope: e.body.scope\n      };\n    })();\n  }\n  set(e) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      var t;\n      const o = new M({\n          clientId: e.client_id,\n          scope: e.scope,\n          audience: e.audience\n        }),\n        n = yield _this5.wrapCacheEntry(e);\n      yield _this5.cache.set(o.toKey(), n), yield null === (t = _this5.keyManifest) || void 0 === t ? void 0 : t.add(o.toKey());\n    })();\n  }\n  clear(e) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      var t;\n      const o = yield _this6.getCacheKeys();\n      o && (yield o.filter(t => !e || t.includes(e)).reduce(/*#__PURE__*/function () {\n        var _ref7 = _asyncToGenerator(function* (e, t) {\n          yield e, yield _this6.cache.remove(t);\n        });\n        return function (_x44, _x45) {\n          return _ref7.apply(this, arguments);\n        };\n      }(), Promise.resolve()), yield null === (t = _this6.keyManifest) || void 0 === t ? void 0 : t.clear());\n    })();\n  }\n  wrapCacheEntry(e) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const t = yield _this7.nowProvider();\n      return {\n        body: e,\n        expiresAt: Math.floor(t / 1e3) + e.expires_in\n      };\n    })();\n  }\n  getCacheKeys() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      var e;\n      return _this8.keyManifest ? null === (e = yield _this8.keyManifest.get()) || void 0 === e ? void 0 : e.keys : _this8.cache.allKeys ? _this8.cache.allKeys() : void 0;\n    })();\n  }\n  getIdTokenCacheKey(e) {\n    return new M({\n      clientId: e\n    }, \"@@auth0spajs@@\", \"@@user@@\").toKey();\n  }\n  matchExistingCacheKey(e, t) {\n    return t.filter(t => {\n      var o;\n      const n = M.fromKey(t),\n        i = new Set(n.scope && n.scope.split(\" \")),\n        r = (null === (o = e.scope) || void 0 === o ? void 0 : o.split(\" \")) || [],\n        s = n.scope && r.reduce((e, t) => e && i.has(t), !0);\n      return \"@@auth0spajs@@\" === n.prefix && n.clientId === e.clientId && n.audience === e.audience && s;\n    })[0];\n  }\n  getEntryWithRefreshToken(e, t) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      var o;\n      for (const n of t) {\n        const t = M.fromKey(n);\n        if (\"@@auth0spajs@@\" === t.prefix && t.clientId === e.clientId) {\n          const t = yield _this9.cache.get(n);\n          if (null === (o = null == t ? void 0 : t.body) || void 0 === o ? void 0 : o.refresh_token) return _this9.modifiedCachedEntry(t, e);\n        }\n      }\n    })();\n  }\n  updateEntry(e, t) {\n    var _this0 = this;\n    return _asyncToGenerator(function* () {\n      var o;\n      const n = yield _this0.getCacheKeys();\n      if (n) for (const i of n) {\n        const n = yield _this0.cache.get(i);\n        if ((null === (o = null == n ? void 0 : n.body) || void 0 === o ? void 0 : o.refresh_token) === e) {\n          const e = Object.assign(Object.assign({}, n.body), {\n            refresh_token: t\n          });\n          yield _this0.set(e);\n        }\n      }\n    })();\n  }\n}\nclass q {\n  constructor(e, t, o) {\n    this.storage = e, this.clientId = t, this.cookieDomain = o, this.storageKey = `a0.spajs.txs.${this.clientId}`;\n  }\n  create(e) {\n    this.storage.save(this.storageKey, e, {\n      daysUntilExpire: 1,\n      cookieDomain: this.cookieDomain\n    });\n  }\n  get() {\n    return this.storage.get(this.storageKey);\n  }\n  remove() {\n    this.storage.remove(this.storageKey, {\n      cookieDomain: this.cookieDomain\n    });\n  }\n}\nconst Q = e => \"number\" == typeof e,\n  ee = [\"iss\", \"aud\", \"exp\", \"nbf\", \"iat\", \"jti\", \"azp\", \"nonce\", \"auth_time\", \"at_hash\", \"c_hash\", \"acr\", \"amr\", \"sub_jwk\", \"cnf\", \"sip_from_tag\", \"sip_date\", \"sip_callid\", \"sip_cseq_num\", \"sip_via_branch\", \"orig\", \"dest\", \"mky\", \"events\", \"toe\", \"txn\", \"rph\", \"sid\", \"vot\", \"vtm\"],\n  te = e => {\n    if (!e.id_token) throw new Error(\"ID token is required but missing\");\n    const t = (e => {\n      const t = e.split(\".\"),\n        [o, n, i] = t;\n      if (3 !== t.length || !o || !n || !i) throw new Error(\"ID token could not be decoded\");\n      const r = JSON.parse(_(n)),\n        s = {\n          __raw: e\n        },\n        a = {};\n      return Object.keys(r).forEach(e => {\n        s[e] = r[e], ee.includes(e) || (a[e] = r[e]);\n      }), {\n        encoded: {\n          header: o,\n          payload: n,\n          signature: i\n        },\n        header: JSON.parse(_(o)),\n        claims: s,\n        user: a\n      };\n    })(e.id_token);\n    if (!t.claims.iss) throw new Error(\"Issuer (iss) claim must be a string present in the ID token\");\n    if (t.claims.iss !== e.iss) throw new Error(`Issuer (iss) claim mismatch in the ID token; expected \"${e.iss}\", found \"${t.claims.iss}\"`);\n    if (!t.user.sub) throw new Error(\"Subject (sub) claim must be a string present in the ID token\");\n    if (\"RS256\" !== t.header.alg) throw new Error(`Signature algorithm of \"${t.header.alg}\" is not supported. Expected the ID token to be signed with \"RS256\".`);\n    if (!t.claims.aud || \"string\" != typeof t.claims.aud && !Array.isArray(t.claims.aud)) throw new Error(\"Audience (aud) claim must be a string or array of strings present in the ID token\");\n    if (Array.isArray(t.claims.aud)) {\n      if (!t.claims.aud.includes(e.aud)) throw new Error(`Audience (aud) claim mismatch in the ID token; expected \"${e.aud}\" but was not one of \"${t.claims.aud.join(\", \")}\"`);\n      if (t.claims.aud.length > 1) {\n        if (!t.claims.azp) throw new Error(\"Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values\");\n        if (t.claims.azp !== e.aud) throw new Error(`Authorized Party (azp) claim mismatch in the ID token; expected \"${e.aud}\", found \"${t.claims.azp}\"`);\n      }\n    } else if (t.claims.aud !== e.aud) throw new Error(`Audience (aud) claim mismatch in the ID token; expected \"${e.aud}\" but found \"${t.claims.aud}\"`);\n    if (e.nonce) {\n      if (!t.claims.nonce) throw new Error(\"Nonce (nonce) claim must be a string present in the ID token\");\n      if (t.claims.nonce !== e.nonce) throw new Error(`Nonce (nonce) claim mismatch in the ID token; expected \"${e.nonce}\", found \"${t.claims.nonce}\"`);\n    }\n    if (e.max_age && !Q(t.claims.auth_time)) throw new Error(\"Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified\");\n    if (null == t.claims.exp || !Q(t.claims.exp)) throw new Error(\"Expiration Time (exp) claim must be a number present in the ID token\");\n    if (!Q(t.claims.iat)) throw new Error(\"Issued At (iat) claim must be a number present in the ID token\");\n    const o = e.leeway || 60,\n      n = new Date(e.now || Date.now()),\n      i = new Date(0);\n    if (i.setUTCSeconds(t.claims.exp + o), n > i) throw new Error(`Expiration Time (exp) claim error in the ID token; current time (${n}) is after expiration time (${i})`);\n    if (null != t.claims.nbf && Q(t.claims.nbf)) {\n      const e = new Date(0);\n      if (e.setUTCSeconds(t.claims.nbf - o), n < e) throw new Error(`Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Current time (${n}) is before ${e}`);\n    }\n    if (null != t.claims.auth_time && Q(t.claims.auth_time)) {\n      const i = new Date(0);\n      if (i.setUTCSeconds(parseInt(t.claims.auth_time) + e.max_age + o), n > i) throw new Error(`Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (${n}) is after last auth at ${i}`);\n    }\n    if (e.organization) {\n      const o = e.organization.trim();\n      if (o.startsWith(\"org_\")) {\n        const e = o;\n        if (!t.claims.org_id) throw new Error(\"Organization ID (org_id) claim must be a string present in the ID token\");\n        if (e !== t.claims.org_id) throw new Error(`Organization ID (org_id) claim mismatch in the ID token; expected \"${e}\", found \"${t.claims.org_id}\"`);\n      } else {\n        const e = o.toLowerCase();\n        if (!t.claims.org_name) throw new Error(\"Organization Name (org_name) claim must be a string present in the ID token\");\n        if (e !== t.claims.org_name) throw new Error(`Organization Name (org_name) claim mismatch in the ID token; expected \"${e}\", found \"${t.claims.org_name}\"`);\n      }\n    }\n    return t;\n  };\nvar oe = n(function (e, o) {\n  var n = t && t.__assign || function () {\n    return n = Object.assign || function (e) {\n      for (var t, o = 1, n = arguments.length; o < n; o++) for (var i in t = arguments[o]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);\n      return e;\n    }, n.apply(this, arguments);\n  };\n  function i(e, t) {\n    if (!t) return \"\";\n    var o = \"; \" + e;\n    return !0 === t ? o : o + \"=\" + t;\n  }\n  function r(e, t, o) {\n    return encodeURIComponent(e).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\") + \"=\" + encodeURIComponent(t).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent) + function (e) {\n      if (\"number\" == typeof e.expires) {\n        var t = new Date();\n        t.setMilliseconds(t.getMilliseconds() + 864e5 * e.expires), e.expires = t;\n      }\n      return i(\"Expires\", e.expires ? e.expires.toUTCString() : \"\") + i(\"Domain\", e.domain) + i(\"Path\", e.path) + i(\"Secure\", e.secure) + i(\"SameSite\", e.sameSite);\n    }(o);\n  }\n  function s(e) {\n    for (var t = {}, o = e ? e.split(\"; \") : [], n = /(%[\\dA-F]{2})+/gi, i = 0; i < o.length; i++) {\n      var r = o[i].split(\"=\"),\n        s = r.slice(1).join(\"=\");\n      '\"' === s.charAt(0) && (s = s.slice(1, -1));\n      try {\n        t[r[0].replace(n, decodeURIComponent)] = s.replace(n, decodeURIComponent);\n      } catch (e) {}\n    }\n    return t;\n  }\n  function a() {\n    return s(document.cookie);\n  }\n  function c(e, t, o) {\n    document.cookie = r(e, t, n({\n      path: \"/\"\n    }, o));\n  }\n  o.__esModule = !0, o.encode = r, o.parse = s, o.getAll = a, o.get = function (e) {\n    return a()[e];\n  }, o.set = c, o.remove = function (e, t) {\n    c(e, \"\", n(n({}, t), {\n      expires: -1\n    }));\n  };\n});\no(oe), oe.encode, oe.parse, oe.getAll;\nvar ne = oe.get,\n  ie = oe.set,\n  re = oe.remove;\nconst se = {\n    get(e) {\n      const t = ne(e);\n      if (void 0 !== t) return JSON.parse(t);\n    },\n    save(e, t, o) {\n      let n = {};\n      \"https:\" === window.location.protocol && (n = {\n        secure: !0,\n        sameSite: \"none\"\n      }), (null == o ? void 0 : o.daysUntilExpire) && (n.expires = o.daysUntilExpire), (null == o ? void 0 : o.cookieDomain) && (n.domain = o.cookieDomain), ie(e, JSON.stringify(t), n);\n    },\n    remove(e, t) {\n      let o = {};\n      (null == t ? void 0 : t.cookieDomain) && (o.domain = t.cookieDomain), re(e, o);\n    }\n  },\n  ae = {\n    get(e) {\n      const t = se.get(e);\n      return t || se.get(`_legacy_${e}`);\n    },\n    save(e, t, o) {\n      let n = {};\n      \"https:\" === window.location.protocol && (n = {\n        secure: !0\n      }), (null == o ? void 0 : o.daysUntilExpire) && (n.expires = o.daysUntilExpire), (null == o ? void 0 : o.cookieDomain) && (n.domain = o.cookieDomain), ie(`_legacy_${e}`, JSON.stringify(t), n), se.save(e, t, o);\n    },\n    remove(e, t) {\n      let o = {};\n      (null == t ? void 0 : t.cookieDomain) && (o.domain = t.cookieDomain), re(e, o), se.remove(e, t), se.remove(`_legacy_${e}`, t);\n    }\n  },\n  ce = {\n    get(e) {\n      if (\"undefined\" == typeof sessionStorage) return;\n      const t = sessionStorage.getItem(e);\n      return null != t ? JSON.parse(t) : void 0;\n    },\n    save(e, t) {\n      sessionStorage.setItem(e, JSON.stringify(t));\n    },\n    remove(e) {\n      sessionStorage.removeItem(e);\n    }\n  };\nfunction ue(e, t, o) {\n  var n = void 0 === t ? null : t,\n    i = function (e, t) {\n      var o = atob(e);\n      if (t) {\n        for (var n = new Uint8Array(o.length), i = 0, r = o.length; i < r; ++i) n[i] = o.charCodeAt(i);\n        return String.fromCharCode.apply(null, new Uint16Array(n.buffer));\n      }\n      return o;\n    }(e, void 0 !== o && o),\n    r = i.indexOf(\"\\n\", 10) + 1,\n    s = i.substring(r) + (n ? \"//# sourceMappingURL=\" + n : \"\"),\n    a = new Blob([s], {\n      type: \"application/javascript\"\n    });\n  return URL.createObjectURL(a);\n}\nvar he,\n  de,\n  le,\n  pe,\n  me = (he = \"Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQscil7c3VwZXIociksdGhpcy5lcnJvcj10LHRoaXMuZXJyb3JfZGVzY3JpcHRpb249cixPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxlLnByb3RvdHlwZSl9c3RhdGljIGZyb21QYXlsb2FkKHtlcnJvcjp0LGVycm9yX2Rlc2NyaXB0aW9uOnJ9KXtyZXR1cm4gbmV3IGUodCxyKX19Y2xhc3MgdCBleHRlbmRzIGV7Y29uc3RydWN0b3IoZSxzKXtzdXBlcigibWlzc2luZ19yZWZyZXNoX3Rva2VuIixgTWlzc2luZyBSZWZyZXNoIFRva2VuIChhdWRpZW5jZTogJyR7cihlLFsiZGVmYXVsdCJdKX0nLCBzY29wZTogJyR7cihzKX0nKWApLHRoaXMuYXVkaWVuY2U9ZSx0aGlzLnNjb3BlPXMsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdC5wcm90b3R5cGUpfX1mdW5jdGlvbiByKGUsdD1bXSl7cmV0dXJuIGUmJiF0LmluY2x1ZGVzKGUpP2U6IiJ9ImZ1bmN0aW9uIj09dHlwZW9mIFN1cHByZXNzZWRFcnJvciYmU3VwcHJlc3NlZEVycm9yO2NvbnN0IHM9ZT0+e3ZhcntjbGllbnRJZDp0fT1lLHI9ZnVuY3Rpb24oZSx0KXt2YXIgcj17fTtmb3IodmFyIHMgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxzKSYmdC5pbmRleE9mKHMpPDAmJihyW3NdPWVbc10pO2lmKG51bGwhPWUmJiJmdW5jdGlvbiI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbz0wO2ZvcihzPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7bzxzLmxlbmd0aDtvKyspdC5pbmRleE9mKHNbb10pPDAmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLHNbb10pJiYocltzW29dXT1lW3Nbb11dKX1yZXR1cm4gcn0oZSxbImNsaWVudElkIl0pO3JldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKChlPT5PYmplY3Qua2V5cyhlKS5maWx0ZXIoKHQ9PnZvaWQgMCE9PWVbdF0pKS5yZWR1Y2UoKCh0LHIpPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse1tyXTplW3JdfSkpLHt9KSkoT2JqZWN0LmFzc2lnbih7Y2xpZW50X2lkOnR9LHIpKSkudG9TdHJpbmcoKX07bGV0IG89e307Y29uc3Qgbj0oZSx0KT0+YCR7ZX18JHt0fWA7YWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsKGFzeW5jKHtkYXRhOnt0aW1lb3V0OmUsYXV0aDpyLGZldGNoVXJsOmksZmV0Y2hPcHRpb25zOmMsdXNlRm9ybURhdGE6YSx1c2VNcnJ0OmZ9LHBvcnRzOltwXX0pPT57bGV0IHUsaCxsPXt9O2NvbnN0e2F1ZGllbmNlOmQsc2NvcGU6eX09cnx8e307dHJ5e2NvbnN0IHI9YT8oZT0+e2NvbnN0IHQ9bmV3IFVSTFNlYXJjaFBhcmFtcyhlKSxyPXt9O3JldHVybiB0LmZvckVhY2goKChlLHQpPT57clt0XT1lfSkpLHJ9KShjLmJvZHkpOkpTT04ucGFyc2UoYy5ib2R5KTtpZighci5yZWZyZXNoX3Rva2VuJiYicmVmcmVzaF90b2tlbiI9PT1yLmdyYW50X3R5cGUpe2lmKGg9KChlLHQpPT5vW24oZSx0KV0pKGQseSksIWgmJmYpe2NvbnN0IGU9by5sYXRlc3RfcmVmcmVzaF90b2tlbix0PSgoZSx0KT0+e2NvbnN0IHI9T2JqZWN0LmtleXMobykuZmluZCgocj0+e2lmKCJsYXRlc3RfcmVmcmVzaF90b2tlbiIhPT1yKXtjb25zdCBzPSgoZSx0KT0+dC5zdGFydHNXaXRoKGAke2V9fGApKSh0LHIpLG89ci5zcGxpdCgifCIpWzFdLnNwbGl0KCIgIiksbj1lLnNwbGl0KCIgIikuZXZlcnkoKGU9Pm8uaW5jbHVkZXMoZSkpKTtyZXR1cm4gcyYmbn19KSk7cmV0dXJuISFyfSkoeSxkKTtlJiYhdCYmKGg9ZSl9aWYoIWgpdGhyb3cgbmV3IHQoZCx5KTtjLmJvZHk9YT9zKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7cmVmcmVzaF90b2tlbjpofSkpOkpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7cmVmcmVzaF90b2tlbjpofSkpfWxldCBqLGs7ImZ1bmN0aW9uIj09dHlwZW9mIEFib3J0Q29udHJvbGxlciYmKGo9bmV3IEFib3J0Q29udHJvbGxlcixjLnNpZ25hbD1qLnNpZ25hbCk7dHJ5e2s9YXdhaXQgUHJvbWlzZS5yYWNlKFsoXz1lLG5ldyBQcm9taXNlKChlPT5zZXRUaW1lb3V0KGUsXykpKSksZmV0Y2goaSxPYmplY3QuYXNzaWduKHt9LGMpKV0pfWNhdGNoKGUpe3JldHVybiB2b2lkIHAucG9zdE1lc3NhZ2Uoe2Vycm9yOmUubWVzc2FnZX0pfWlmKCFrKXJldHVybiBqJiZqLmFib3J0KCksdm9pZCBwLnBvc3RNZXNzYWdlKHtlcnJvcjoiVGltZW91dCB3aGVuIGV4ZWN1dGluZyAnZmV0Y2gnIn0pO2c9ay5oZWFkZXJzLGw9Wy4uLmddLnJlZHVjZSgoKGUsW3Qscl0pPT4oZVt0XT1yLGUpKSx7fSksdT1hd2FpdCBrLmpzb24oKSx1LnJlZnJlc2hfdG9rZW4/KGYmJiJkZWZhdWx0IiE9PWQmJihvLmxhdGVzdF9yZWZyZXNoX3Rva2VuPXUucmVmcmVzaF90b2tlbixPPWgsYj11LnJlZnJlc2hfdG9rZW4sT2JqZWN0LmVudHJpZXMobykuZm9yRWFjaCgoKFtlLHRdKT0+e3Q9PT1PJiYob1tlXT1iKX0pKSksKChlLHQscik9PntvW24odCxyKV09ZX0pKHUucmVmcmVzaF90b2tlbixkLHkpLGRlbGV0ZSB1LnJlZnJlc2hfdG9rZW4pOigoZSx0KT0+e2RlbGV0ZSBvW24oZSx0KV19KShkLHkpLHAucG9zdE1lc3NhZ2Uoe29rOmsub2ssanNvbjp1LGhlYWRlcnM6bH0pfWNhdGNoKGUpe3AucG9zdE1lc3NhZ2Uoe29rOiExLGpzb246e2Vycm9yOmUuZXJyb3IsZXJyb3JfZGVzY3JpcHRpb246ZS5tZXNzYWdlfSxoZWFkZXJzOmx9KX12YXIgTyxiLGcsX30pKX0oKTsKCg==\", de = null, le = !1, function (e) {\n    return pe = pe || ue(he, de, le), new Worker(pe, e);\n  });\nconst fe = {};\nclass ge {\n  constructor(e, t) {\n    this.cache = e, this.clientId = t, this.manifestKey = this.createManifestKeyFrom(this.clientId);\n  }\n  add(e) {\n    var _this1 = this;\n    return _asyncToGenerator(function* () {\n      var t;\n      const o = new Set((null === (t = yield _this1.cache.get(_this1.manifestKey)) || void 0 === t ? void 0 : t.keys) || []);\n      o.add(e), yield _this1.cache.set(_this1.manifestKey, {\n        keys: [...o]\n      });\n    })();\n  }\n  remove(e) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const t = yield _this10.cache.get(_this10.manifestKey);\n      if (t) {\n        const o = new Set(t.keys);\n        return o.delete(e), o.size > 0 ? yield _this10.cache.set(_this10.manifestKey, {\n          keys: [...o]\n        }) : yield _this10.cache.remove(_this10.manifestKey);\n      }\n    })();\n  }\n  get() {\n    return this.cache.get(this.manifestKey);\n  }\n  clear() {\n    return this.cache.remove(this.manifestKey);\n  }\n  createManifestKeyFrom(e) {\n    return `@@auth0spajs@@::${e}`;\n  }\n}\nconst ye = {\n    memory: () => new $().enclosedCache,\n    localstorage: () => new Y()\n  },\n  we = e => ye[e],\n  be = t => {\n    const {\n        openUrl: o,\n        onRedirect: n\n      } = t,\n      i = e(t, [\"openUrl\", \"onRedirect\"]);\n    return Object.assign(Object.assign({}, i), {\n      openUrl: !1 === o || o ? o : n\n    });\n  },\n  ke = (e, t) => {\n    const o = (null == t ? void 0 : t.split(\" \")) || [];\n    return ((null == e ? void 0 : e.split(\" \")) || []).every(e => o.includes(e));\n  },\n  ve = {\n    NONCE: \"nonce\",\n    KEYPAIR: \"keypair\"\n  };\nclass _e {\n  constructor(e) {\n    this.clientId = e;\n  }\n  getVersion() {\n    return 1;\n  }\n  createDbHandle() {\n    const e = window.indexedDB.open(\"auth0-spa-js\", this.getVersion());\n    return new Promise((t, o) => {\n      e.onupgradeneeded = () => Object.values(ve).forEach(t => e.result.createObjectStore(t)), e.onerror = () => o(e.error), e.onsuccess = () => t(e.result);\n    });\n  }\n  getDbHandle() {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      return _this11.dbHandle || (_this11.dbHandle = yield _this11.createDbHandle()), _this11.dbHandle;\n    })();\n  }\n  executeDbRequest(e, t, o) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const n = o((yield _this12.getDbHandle()).transaction(e, t).objectStore(e));\n      return new Promise((e, t) => {\n        n.onsuccess = () => e(n.result), n.onerror = () => t(n.error);\n      });\n    })();\n  }\n  buildKey(e) {\n    const t = e ? `_${e}` : \"auth0\";\n    return `${this.clientId}::${t}`;\n  }\n  setNonce(e, t) {\n    return this.save(ve.NONCE, this.buildKey(t), e);\n  }\n  setKeyPair(e) {\n    return this.save(ve.KEYPAIR, this.buildKey(), e);\n  }\n  save(e, t, o) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      yield _this13.executeDbRequest(e, \"readwrite\", e => e.put(o, t));\n    })();\n  }\n  findNonce(e) {\n    return this.find(ve.NONCE, this.buildKey(e));\n  }\n  findKeyPair() {\n    return this.find(ve.KEYPAIR, this.buildKey());\n  }\n  find(e, t) {\n    return this.executeDbRequest(e, \"readonly\", e => e.get(t));\n  }\n  deleteBy(e, t) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const o = yield _this14.executeDbRequest(e, \"readonly\", e => e.getAllKeys());\n      null == o || o.filter(t).map(t => _this14.executeDbRequest(e, \"readwrite\", e => e.delete(t)));\n    })();\n  }\n  deleteByClientId(e, t) {\n    return this.deleteBy(e, e => \"string\" == typeof e && e.startsWith(`${t}::`));\n  }\n  clearNonces() {\n    return this.deleteByClientId(ve.NONCE, this.clientId);\n  }\n  clearKeyPairs() {\n    return this.deleteByClientId(ve.KEYPAIR, this.clientId);\n  }\n}\nclass Ie {\n  constructor(e) {\n    this.storage = new _e(e);\n  }\n  getNonce(e) {\n    return this.storage.findNonce(e);\n  }\n  setNonce(e, t) {\n    return this.storage.setNonce(e, t);\n  }\n  getOrGenerateKeyPair() {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      let e = yield _this15.storage.findKeyPair();\n      return e || (e = yield U(), yield _this15.storage.setKeyPair(e)), e;\n    })();\n  }\n  generateProof(e) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const t = yield _this16.getOrGenerateKeyPair();\n      return W(Object.assign({\n        keyPair: t\n      }, e));\n    })();\n  }\n  calculateThumbprint() {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      return L(yield _this17.getOrGenerateKeyPair());\n    })();\n  }\n  clear() {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      yield Promise.all([_this18.storage.clearNonces(), _this18.storage.clearKeyPairs()]);\n    })();\n  }\n}\nclass Se {\n  constructor(e, t) {\n    this.hooks = t, this.config = Object.assign(Object.assign({}, e), {\n      fetch: e.fetch || (\"undefined\" == typeof window ? fetch : window.fetch.bind(window))\n    });\n  }\n  isAbsoluteUrl(e) {\n    return /^(https?:)?\\/\\//i.test(e);\n  }\n  buildUrl(e, t) {\n    if (t) {\n      if (this.isAbsoluteUrl(t)) return t;\n      if (e) return `${e.replace(/\\/?\\/$/, \"\")}/${t.replace(/^\\/+/, \"\")}`;\n    }\n    throw new TypeError(\"`url` must be absolute or `baseUrl` non-empty.\");\n  }\n  getAccessToken(e) {\n    return this.config.getAccessToken ? this.config.getAccessToken(e) : this.hooks.getAccessToken(e);\n  }\n  buildBaseRequest(e, t) {\n    const o = new Request(e, t);\n    return this.config.baseUrl ? new Request(this.buildUrl(this.config.baseUrl, o.url), o) : o;\n  }\n  setAuthorizationHeader(e, t) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      e.headers.set(\"authorization\", `${_this19.config.dpopNonceId ? \"DPoP\" : \"Bearer\"} ${t}`);\n    })();\n  }\n  setDpopProofHeader(e, t) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this20.config.dpopNonceId) return;\n      const o = yield _this20.hooks.getDpopNonce(),\n        n = yield _this20.hooks.generateDpopProof({\n          accessToken: t,\n          method: e.method,\n          nonce: o,\n          url: e.url\n        });\n      e.headers.set(\"dpop\", n);\n    })();\n  }\n  prepareRequest(e, t) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      const o = yield _this21.getAccessToken(t);\n      _this21.setAuthorizationHeader(e, o), yield _this21.setDpopProofHeader(e, o);\n    })();\n  }\n  getHeader(e, t) {\n    return Array.isArray(e) ? new Headers(e).get(t) || \"\" : \"function\" == typeof e.get ? e.get(t) || \"\" : e[t] || \"\";\n  }\n  hasUseDpopNonceError(e) {\n    if (401 !== e.status) return !1;\n    return this.getHeader(e.headers, \"www-authenticate\").includes(\"use_dpop_nonce\");\n  }\n  handleResponse(e, t) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      const o = _this22.getHeader(e.headers, \"dpop-nonce\");\n      if (o && (yield _this22.hooks.setDpopNonce(o)), !_this22.hasUseDpopNonceError(e)) return e;\n      if (!o || !t.onUseDpopNonceError) throw new g(o);\n      return t.onUseDpopNonceError();\n    })();\n  }\n  internalFetchWithAuth(e, t, o, n) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      const i = _this23.buildBaseRequest(e, t);\n      yield _this23.prepareRequest(i, n);\n      const r = yield _this23.config.fetch(i);\n      return _this23.handleResponse(r, o);\n    })();\n  }\n  fetchWithAuth(e, t, o) {\n    const n = {\n      onUseDpopNonceError: () => this.internalFetchWithAuth(e, t, Object.assign(Object.assign({}, n), {\n        onUseDpopNonceError: void 0\n      }), o)\n    };\n    return this.internalFetchWithAuth(e, t, n, o);\n  }\n}\nconst Te = new r();\nclass Pe {\n  constructor(e) {\n    var _this24 = this;\n    let t, o;\n    if (this.userCache = new $().enclosedCache, this.defaultOptions = {\n      authorizationParams: {\n        scope: \"openid profile email\"\n      },\n      useRefreshTokensFallback: !1,\n      useFormData: !0\n    }, this._releaseLockOnPageHide = /*#__PURE__*/_asyncToGenerator(function* () {\n      yield Te.releaseLock(\"auth0.lock.getTokenSilently\"), window.removeEventListener(\"pagehide\", _this24._releaseLockOnPageHide);\n    }), this.options = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), e), {\n      authorizationParams: Object.assign(Object.assign({}, this.defaultOptions.authorizationParams), e.authorizationParams)\n    }), \"undefined\" != typeof window && (() => {\n      if (!w()) throw new Error(\"For security reasons, `window.crypto` is required to run `auth0-spa-js`.\");\n      if (void 0 === w().subtle) throw new Error(\"\\n      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/main/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.\\n    \");\n    })(), e.cache && e.cacheLocation && console.warn(\"Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`.\"), e.cache) o = e.cache;else {\n      if (t = e.cacheLocation || \"memory\", !we(t)) throw new Error(`Invalid cache location \"${t}\"`);\n      o = we(t)();\n    }\n    this.httpTimeoutMs = e.httpTimeoutInSeconds ? 1e3 * e.httpTimeoutInSeconds : 1e4, this.cookieStorage = !1 === e.legacySameSiteCookie ? se : ae, this.orgHintCookieName = `auth0.${this.options.clientId}.organization_hint`, this.isAuthenticatedCookieName = (e => `auth0.${e}.is.authenticated`)(this.options.clientId), this.sessionCheckExpiryDays = e.sessionCheckExpiryDays || 1;\n    const n = e.useCookiesForTransactions ? this.cookieStorage : ce;\n    var i;\n    this.scope = F(\"openid\", this.options.authorizationParams.scope, this.options.useRefreshTokens ? \"offline_access\" : \"\"), this.transactionManager = new q(n, this.options.clientId, this.options.cookieDomain), this.nowProvider = this.options.nowProvider || c, this.cacheManager = new B(o, o.allKeys ? void 0 : new ge(o, this.options.clientId), this.nowProvider), this.dpop = this.options.useDpop ? new Ie(this.options.clientId) : void 0, this.domainUrl = (i = this.options.domain, /^https?:\\/\\//.test(i) ? i : `https://${i}`), this.tokenIssuer = ((e, t) => e ? e.startsWith(\"https://\") ? e : `https://${e}/` : `${t}/`)(this.options.issuer, this.domainUrl), \"undefined\" != typeof window && window.Worker && this.options.useRefreshTokens && \"memory\" === t && (this.options.workerUrl ? this.worker = new Worker(this.options.workerUrl) : this.worker = new me());\n  }\n  _url(e) {\n    const t = encodeURIComponent(btoa(JSON.stringify(this.options.auth0Client || a)));\n    return `${this.domainUrl}${e}&auth0Client=${t}`;\n  }\n  _authorizeUrl(e) {\n    return this._url(`/authorize?${v(e)}`);\n  }\n  _verifyIdToken(e, t, o) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      const n = yield _this25.nowProvider();\n      return te({\n        iss: _this25.tokenIssuer,\n        aud: _this25.options.clientId,\n        id_token: e,\n        nonce: t,\n        organization: o,\n        leeway: _this25.options.leeway,\n        max_age: (i = _this25.options.authorizationParams.max_age, \"string\" != typeof i ? i : parseInt(i, 10) || void 0),\n        now: n\n      });\n      var i;\n    })();\n  }\n  _processOrgHint(e) {\n    e ? this.cookieStorage.save(this.orgHintCookieName, e, {\n      daysUntilExpire: this.sessionCheckExpiryDays,\n      cookieDomain: this.options.cookieDomain\n    }) : this.cookieStorage.remove(this.orgHintCookieName, {\n      cookieDomain: this.options.cookieDomain\n    });\n  }\n  _prepareAuthorizeUrl(e, t, o) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      var n;\n      const i = k(b()),\n        r = k(b()),\n        s = b(),\n        a = (e => {\n          const t = new Uint8Array(e);\n          return (e => {\n            const t = {\n              \"+\": \"-\",\n              \"/\": \"_\",\n              \"=\": \"\"\n            };\n            return e.replace(/[+/=]/g, e => t[e]);\n          })(window.btoa(String.fromCharCode(...Array.from(t))));\n        })(yield function () {\n          var _ref9 = _asyncToGenerator(function* (e) {\n            const t = w().subtle.digest({\n              name: \"SHA-256\"\n            }, new TextEncoder().encode(e));\n            return yield t;\n          });\n          return function (_x46) {\n            return _ref9.apply(this, arguments);\n          };\n        }()(s)),\n        c = yield null === (n = _this26.dpop) || void 0 === n ? void 0 : n.calculateThumbprint(),\n        u = ((e, t, o, n, i, r, s, a, c) => Object.assign(Object.assign(Object.assign({\n          client_id: e.clientId\n        }, e.authorizationParams), o), {\n          scope: F(t, o.scope),\n          response_type: \"code\",\n          response_mode: a || \"query\",\n          state: n,\n          nonce: i,\n          redirect_uri: s || e.authorizationParams.redirect_uri,\n          code_challenge: r,\n          code_challenge_method: \"S256\",\n          dpop_jkt: c\n        }))(_this26.options, _this26.scope, e, i, r, a, e.redirect_uri || _this26.options.authorizationParams.redirect_uri || o, null == t ? void 0 : t.response_mode, c),\n        h = _this26._authorizeUrl(u);\n      return {\n        nonce: r,\n        code_verifier: s,\n        scope: u.scope,\n        audience: u.audience || \"default\",\n        redirect_uri: u.redirect_uri,\n        state: i,\n        url: h\n      };\n    })();\n  }\n  loginWithPopup(e, t) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      var o;\n      if (e = e || {}, !(t = t || {}).popup && (t.popup = (e => {\n        const t = window.screenX + (window.innerWidth - 400) / 2,\n          o = window.screenY + (window.innerHeight - 600) / 2;\n        return window.open(e, \"auth0:authorize:popup\", `left=${t},top=${o},width=400,height=600,resizable,scrollbars=yes,status=1`);\n      })(\"\"), !t.popup)) throw new Error(\"Unable to open a popup for loginWithPopup - window.open returned `null`\");\n      const n = yield _this27._prepareAuthorizeUrl(e.authorizationParams || {}, {\n        response_mode: \"web_message\"\n      }, window.location.origin);\n      t.popup.location.href = n.url;\n      const i = yield (e => new Promise((t, o) => {\n        let n;\n        const i = setInterval(() => {\n            e.popup && e.popup.closed && (clearInterval(i), clearTimeout(r), window.removeEventListener(\"message\", n, !1), o(new p(e.popup)));\n          }, 1e3),\n          r = setTimeout(() => {\n            clearInterval(i), o(new l(e.popup)), window.removeEventListener(\"message\", n, !1);\n          }, 1e3 * (e.timeoutInSeconds || 60));\n        n = function (s) {\n          if (s.data && \"authorization_response\" === s.data.type) {\n            if (clearTimeout(r), clearInterval(i), window.removeEventListener(\"message\", n, !1), e.popup.close(), s.data.response.error) return o(u.fromPayload(s.data.response));\n            t(s.data.response);\n          }\n        }, window.addEventListener(\"message\", n);\n      }))(Object.assign(Object.assign({}, t), {\n        timeoutInSeconds: t.timeoutInSeconds || _this27.options.authorizeTimeoutInSeconds || 60\n      }));\n      if (n.state !== i.state) throw new u(\"state_mismatch\", \"Invalid state\");\n      const r = (null === (o = e.authorizationParams) || void 0 === o ? void 0 : o.organization) || _this27.options.authorizationParams.organization;\n      yield _this27._requestToken({\n        audience: n.audience,\n        scope: n.scope,\n        code_verifier: n.code_verifier,\n        grant_type: \"authorization_code\",\n        code: i.code,\n        redirect_uri: n.redirect_uri\n      }, {\n        nonceIn: n.nonce,\n        organization: r\n      });\n    })();\n  }\n  getUser() {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      var e;\n      const t = yield _this28._getIdTokenFromCache();\n      return null === (e = null == t ? void 0 : t.decodedToken) || void 0 === e ? void 0 : e.user;\n    })();\n  }\n  getIdTokenClaims() {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      var e;\n      const t = yield _this29._getIdTokenFromCache();\n      return null === (e = null == t ? void 0 : t.decodedToken) || void 0 === e ? void 0 : e.claims;\n    })();\n  }\n  loginWithRedirect() {\n    var _this30 = this;\n    return _asyncToGenerator(function* (t = {}) {\n      var o;\n      const n = be(t),\n        {\n          openUrl: i,\n          fragment: r,\n          appState: s\n        } = n,\n        a = e(n, [\"openUrl\", \"fragment\", \"appState\"]),\n        c = (null === (o = a.authorizationParams) || void 0 === o ? void 0 : o.organization) || _this30.options.authorizationParams.organization,\n        u = yield _this30._prepareAuthorizeUrl(a.authorizationParams || {}),\n        {\n          url: h\n        } = u,\n        d = e(u, [\"url\"]);\n      _this30.transactionManager.create(Object.assign(Object.assign(Object.assign({}, d), {\n        appState: s\n      }), c && {\n        organization: c\n      }));\n      const l = r ? `${h}#${r}` : h;\n      i ? yield i(l) : window.location.assign(l);\n    }).apply(this, arguments);\n  }\n  handleRedirectCallback() {\n    var _this31 = this;\n    return _asyncToGenerator(function* (e = window.location.href) {\n      const t = e.split(\"?\").slice(1);\n      if (0 === t.length) throw new Error(\"There are no query params available for parsing.\");\n      const {\n          state: o,\n          code: n,\n          error: i,\n          error_description: r\n        } = (e => {\n          e.indexOf(\"#\") > -1 && (e = e.substring(0, e.indexOf(\"#\")));\n          const t = new URLSearchParams(e);\n          return {\n            state: t.get(\"state\"),\n            code: t.get(\"code\") || void 0,\n            error: t.get(\"error\") || void 0,\n            error_description: t.get(\"error_description\") || void 0\n          };\n        })(t.join(\"\")),\n        s = _this31.transactionManager.get();\n      if (!s) throw new u(\"missing_transaction\", \"Invalid state\");\n      if (_this31.transactionManager.remove(), i) throw new h(i, r || i, o, s.appState);\n      if (!s.code_verifier || s.state && s.state !== o) throw new u(\"state_mismatch\", \"Invalid state\");\n      const a = s.organization,\n        c = s.nonce,\n        d = s.redirect_uri;\n      return yield _this31._requestToken(Object.assign({\n        audience: s.audience,\n        scope: s.scope,\n        code_verifier: s.code_verifier,\n        grant_type: \"authorization_code\",\n        code: n\n      }, d ? {\n        redirect_uri: d\n      } : {}), {\n        nonceIn: c,\n        organization: a\n      }), {\n        appState: s.appState\n      };\n    }).apply(this, arguments);\n  }\n  checkSession(e) {\n    var _this32 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this32.cookieStorage.get(_this32.isAuthenticatedCookieName)) {\n        if (!_this32.cookieStorage.get(\"auth0.is.authenticated\")) return;\n        _this32.cookieStorage.save(_this32.isAuthenticatedCookieName, !0, {\n          daysUntilExpire: _this32.sessionCheckExpiryDays,\n          cookieDomain: _this32.options.cookieDomain\n        }), _this32.cookieStorage.remove(\"auth0.is.authenticated\");\n      }\n      try {\n        yield _this32.getTokenSilently(e);\n      } catch (e) {}\n    })();\n  }\n  getTokenSilently() {\n    var _this33 = this;\n    return _asyncToGenerator(function* (e = {}) {\n      var t;\n      const o = Object.assign(Object.assign({\n          cacheMode: \"on\"\n        }, e), {\n          authorizationParams: Object.assign(Object.assign(Object.assign({}, _this33.options.authorizationParams), e.authorizationParams), {\n            scope: F(_this33.scope, null === (t = e.authorizationParams) || void 0 === t ? void 0 : t.scope)\n          })\n        }),\n        n = yield ((e, t) => {\n          let o = fe[t];\n          return o || (o = e().finally(() => {\n            delete fe[t], o = null;\n          }), fe[t] = o), o;\n        })(() => _this33._getTokenSilently(o), `${_this33.options.clientId}::${o.authorizationParams.audience}::${o.authorizationParams.scope}`);\n      return e.detailedResponse ? n : null == n ? void 0 : n.access_token;\n    }).apply(this, arguments);\n  }\n  _getTokenSilently(t) {\n    var _this34 = this;\n    return _asyncToGenerator(function* () {\n      const {\n          cacheMode: o\n        } = t,\n        n = e(t, [\"cacheMode\"]);\n      if (\"off\" !== o) {\n        const e = yield _this34._getEntryFromCache({\n          scope: n.authorizationParams.scope,\n          audience: n.authorizationParams.audience || \"default\",\n          clientId: _this34.options.clientId,\n          cacheMode: o\n        });\n        if (e) return e;\n      }\n      if (\"cache-only\" !== o) {\n        if (!(yield function () {\n          var _ref0 = _asyncToGenerator(function* (e, t = 3) {\n            for (let o = 0; o < t; o++) if (yield e()) return !0;\n            return !1;\n          });\n          return function (_x47) {\n            return _ref0.apply(this, arguments);\n          };\n        }()(() => Te.acquireLock(\"auth0.lock.getTokenSilently\", 5e3), 10))) throw new d();\n        try {\n          if (window.addEventListener(\"pagehide\", _this34._releaseLockOnPageHide), \"off\" !== o) {\n            const e = yield _this34._getEntryFromCache({\n              scope: n.authorizationParams.scope,\n              audience: n.authorizationParams.audience || \"default\",\n              clientId: _this34.options.clientId\n            });\n            if (e) return e;\n          }\n          const e = _this34.options.useRefreshTokens ? yield _this34._getTokenUsingRefreshToken(n) : yield _this34._getTokenFromIFrame(n),\n            {\n              id_token: t,\n              token_type: i,\n              access_token: r,\n              oauthTokenScope: s,\n              expires_in: a\n            } = e;\n          return Object.assign(Object.assign({\n            id_token: t,\n            token_type: i,\n            access_token: r\n          }, s ? {\n            scope: s\n          } : null), {\n            expires_in: a\n          });\n        } finally {\n          yield Te.releaseLock(\"auth0.lock.getTokenSilently\"), window.removeEventListener(\"pagehide\", _this34._releaseLockOnPageHide);\n        }\n      }\n    })();\n  }\n  getTokenWithPopup() {\n    var _this35 = this;\n    return _asyncToGenerator(function* (e = {}, t = {}) {\n      var o;\n      const n = Object.assign(Object.assign({}, e), {\n        authorizationParams: Object.assign(Object.assign(Object.assign({}, _this35.options.authorizationParams), e.authorizationParams), {\n          scope: F(_this35.scope, null === (o = e.authorizationParams) || void 0 === o ? void 0 : o.scope)\n        })\n      });\n      t = Object.assign(Object.assign({}, s), t), yield _this35.loginWithPopup(n, t);\n      return (yield _this35.cacheManager.get(new M({\n        scope: n.authorizationParams.scope,\n        audience: n.authorizationParams.audience || \"default\",\n        clientId: _this35.options.clientId\n      }), void 0, _this35.options.useMrrt)).access_token;\n    }).apply(this, arguments);\n  }\n  isAuthenticated() {\n    var _this36 = this;\n    return _asyncToGenerator(function* () {\n      return !!(yield _this36.getUser());\n    })();\n  }\n  _buildLogoutUrl(t) {\n    null !== t.clientId ? t.clientId = t.clientId || this.options.clientId : delete t.clientId;\n    const o = t.logoutParams || {},\n      {\n        federated: n\n      } = o,\n      i = e(o, [\"federated\"]),\n      r = n ? \"&federated\" : \"\";\n    return this._url(`/v2/logout?${v(Object.assign({\n      clientId: t.clientId\n    }, i))}`) + r;\n  }\n  logout() {\n    var _this37 = this;\n    return _asyncToGenerator(function* (t = {}) {\n      var o;\n      const n = be(t),\n        {\n          openUrl: i\n        } = n,\n        r = e(n, [\"openUrl\"]);\n      null === t.clientId ? yield _this37.cacheManager.clear() : yield _this37.cacheManager.clear(t.clientId || _this37.options.clientId), _this37.cookieStorage.remove(_this37.orgHintCookieName, {\n        cookieDomain: _this37.options.cookieDomain\n      }), _this37.cookieStorage.remove(_this37.isAuthenticatedCookieName, {\n        cookieDomain: _this37.options.cookieDomain\n      }), _this37.userCache.remove(\"@@user@@\"), yield null === (o = _this37.dpop) || void 0 === o ? void 0 : o.clear();\n      const s = _this37._buildLogoutUrl(r);\n      i ? yield i(s) : !1 !== i && window.location.assign(s);\n    }).apply(this, arguments);\n  }\n  _getTokenFromIFrame(e) {\n    var _this38 = this;\n    return _asyncToGenerator(function* () {\n      const t = Object.assign(Object.assign({}, e.authorizationParams), {\n          prompt: \"none\"\n        }),\n        o = _this38.cookieStorage.get(_this38.orgHintCookieName);\n      o && !t.organization && (t.organization = o);\n      const {\n        url: n,\n        state: i,\n        nonce: r,\n        code_verifier: s,\n        redirect_uri: a,\n        scope: c,\n        audience: h\n      } = yield _this38._prepareAuthorizeUrl(t, {\n        response_mode: \"web_message\"\n      }, window.location.origin);\n      try {\n        if (window.crossOriginIsolated) throw new u(\"login_required\", \"The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible.\");\n        const o = e.timeoutInSeconds || _this38.options.authorizeTimeoutInSeconds;\n        let l;\n        try {\n          l = new URL(_this38.domainUrl).origin;\n        } catch (e) {\n          l = _this38.domainUrl;\n        }\n        const p = yield ((e, t, o = 60) => new Promise((n, i) => {\n          const r = window.document.createElement(\"iframe\");\n          r.setAttribute(\"width\", \"0\"), r.setAttribute(\"height\", \"0\"), r.style.display = \"none\";\n          const s = () => {\n            window.document.body.contains(r) && (window.document.body.removeChild(r), window.removeEventListener(\"message\", a, !1));\n          };\n          let a;\n          const c = setTimeout(() => {\n            i(new d()), s();\n          }, 1e3 * o);\n          a = function (e) {\n            if (e.origin != t) return;\n            if (!e.data || \"authorization_response\" !== e.data.type) return;\n            const o = e.source;\n            o && o.close(), e.data.response.error ? i(u.fromPayload(e.data.response)) : n(e.data.response), clearTimeout(c), window.removeEventListener(\"message\", a, !1), setTimeout(s, 2e3);\n          }, window.addEventListener(\"message\", a, !1), window.document.body.appendChild(r), r.setAttribute(\"src\", e);\n        }))(n, l, o);\n        if (i !== p.state) throw new u(\"state_mismatch\", \"Invalid state\");\n        const m = yield _this38._requestToken(Object.assign(Object.assign({}, e.authorizationParams), {\n          code_verifier: s,\n          code: p.code,\n          grant_type: \"authorization_code\",\n          redirect_uri: a,\n          timeout: e.authorizationParams.timeout || _this38.httpTimeoutMs\n        }), {\n          nonceIn: r,\n          organization: t.organization\n        });\n        return Object.assign(Object.assign({}, m), {\n          scope: c,\n          oauthTokenScope: m.scope,\n          audience: h\n        });\n      } catch (e) {\n        throw \"login_required\" === e.error && _this38.logout({\n          openUrl: !1\n        }), e;\n      }\n    })();\n  }\n  _getTokenUsingRefreshToken(e) {\n    var _this39 = this;\n    return _asyncToGenerator(function* () {\n      const t = yield _this39.cacheManager.get(new M({\n        scope: e.authorizationParams.scope,\n        audience: e.authorizationParams.audience || \"default\",\n        clientId: _this39.options.clientId\n      }), void 0, _this39.options.useMrrt);\n      if (!(t && t.refresh_token || _this39.worker)) {\n        if (_this39.options.useRefreshTokensFallback) return yield _this39._getTokenFromIFrame(e);\n        throw new f(e.authorizationParams.audience || \"default\", e.authorizationParams.scope);\n      }\n      const o = e.authorizationParams.redirect_uri || _this39.options.authorizationParams.redirect_uri || window.location.origin,\n        n = \"number\" == typeof e.timeoutInSeconds ? 1e3 * e.timeoutInSeconds : null,\n        i = ((e, t, o, n) => {\n          var i;\n          if (e && o && n) {\n            if (t.audience !== o) return t.scope;\n            const e = n.split(\" \"),\n              r = (null === (i = t.scope) || void 0 === i ? void 0 : i.split(\" \")) || [],\n              s = r.every(t => e.includes(t));\n            return e.length >= r.length && s ? n : t.scope;\n          }\n          return t.scope;\n        })(_this39.options.useMrrt, e.authorizationParams, null == t ? void 0 : t.audience, null == t ? void 0 : t.scope);\n      try {\n        const u = yield _this39._requestToken(Object.assign(Object.assign(Object.assign({}, e.authorizationParams), {\n          grant_type: \"refresh_token\",\n          refresh_token: t && t.refresh_token,\n          redirect_uri: o\n        }), n && {\n          timeout: n\n        }), {\n          scopesToRequest: i\n        });\n        if (u.refresh_token && _this39.options.useMrrt && (null == t ? void 0 : t.refresh_token) && (yield _this39.cacheManager.updateEntry(t.refresh_token, u.refresh_token)), _this39.options.useMrrt) {\n          if (r = null == t ? void 0 : t.audience, s = null == t ? void 0 : t.scope, a = e.authorizationParams.audience, c = e.authorizationParams.scope, r !== a || !ke(c, s)) {\n            if (!ke(i, u.scope)) {\n              if (_this39.options.useRefreshTokensFallback) return yield _this39._getTokenFromIFrame(e);\n              throw new f(e.authorizationParams.audience || \"default\", e.authorizationParams.scope);\n            }\n          }\n        }\n        return Object.assign(Object.assign({}, u), {\n          scope: e.authorizationParams.scope,\n          oauthTokenScope: u.scope,\n          audience: e.authorizationParams.audience || \"default\"\n        });\n      } catch (t) {\n        if ((t.message.indexOf(\"Missing Refresh Token\") > -1 || t.message && t.message.indexOf(\"invalid refresh token\") > -1) && _this39.options.useRefreshTokensFallback) return yield _this39._getTokenFromIFrame(e);\n        throw t;\n      }\n      var r, s, a, c;\n    })();\n  }\n  _saveEntryInCache(t) {\n    var _this40 = this;\n    return _asyncToGenerator(function* () {\n      const {\n          id_token: o,\n          decodedToken: n\n        } = t,\n        i = e(t, [\"id_token\", \"decodedToken\"]);\n      _this40.userCache.set(\"@@user@@\", {\n        id_token: o,\n        decodedToken: n\n      }), yield _this40.cacheManager.setIdToken(_this40.options.clientId, t.id_token, t.decodedToken), yield _this40.cacheManager.set(i);\n    })();\n  }\n  _getIdTokenFromCache() {\n    var _this41 = this;\n    return _asyncToGenerator(function* () {\n      const e = _this41.options.authorizationParams.audience || \"default\",\n        t = yield _this41.cacheManager.getIdToken(new M({\n          clientId: _this41.options.clientId,\n          audience: e,\n          scope: _this41.scope\n        })),\n        o = _this41.userCache.get(\"@@user@@\");\n      return t && t.id_token === (null == o ? void 0 : o.id_token) ? o : (_this41.userCache.set(\"@@user@@\", t), t);\n    })();\n  }\n  _getEntryFromCache(_x48) {\n    var _this42 = this;\n    return _asyncToGenerator(function* ({\n      scope: e,\n      audience: t,\n      clientId: o,\n      cacheMode: n\n    }) {\n      const i = yield _this42.cacheManager.get(new M({\n        scope: e,\n        audience: t,\n        clientId: o\n      }), 60, _this42.options.useMrrt, n);\n      if (i && i.access_token) {\n        const {\n            token_type: e,\n            access_token: t,\n            oauthTokenScope: o,\n            expires_in: n\n          } = i,\n          r = yield _this42._getIdTokenFromCache();\n        return r && Object.assign(Object.assign({\n          id_token: r.id_token,\n          token_type: e || \"Bearer\",\n          access_token: t\n        }, o ? {\n          scope: o\n        } : null), {\n          expires_in: n\n        });\n      }\n    }).apply(this, arguments);\n  }\n  _requestToken(e, t) {\n    var _this43 = this;\n    return _asyncToGenerator(function* () {\n      const {\n          nonceIn: o,\n          organization: n,\n          scopesToRequest: i\n        } = t || {},\n        r = yield G(Object.assign(Object.assign({\n          baseUrl: _this43.domainUrl,\n          client_id: _this43.options.clientId,\n          auth0Client: _this43.options.auth0Client,\n          useFormData: _this43.options.useFormData,\n          timeout: _this43.httpTimeoutMs,\n          useMrrt: _this43.options.useMrrt,\n          dpop: _this43.dpop\n        }, e), {\n          scope: i || e.scope\n        }), _this43.worker),\n        s = yield _this43._verifyIdToken(r.id_token, o, n);\n      return yield _this43._saveEntryInCache(Object.assign(Object.assign(Object.assign(Object.assign({}, r), {\n        decodedToken: s,\n        scope: e.scope,\n        audience: e.audience || \"default\"\n      }), r.scope ? {\n        oauthTokenScope: r.scope\n      } : null), {\n        client_id: _this43.options.clientId\n      })), _this43.cookieStorage.save(_this43.isAuthenticatedCookieName, !0, {\n        daysUntilExpire: _this43.sessionCheckExpiryDays,\n        cookieDomain: _this43.options.cookieDomain\n      }), _this43._processOrgHint(n || s.claims.org_id), Object.assign(Object.assign({}, r), {\n        decodedToken: s\n      });\n    })();\n  }\n  exchangeToken(e) {\n    var _this44 = this;\n    return _asyncToGenerator(function* () {\n      return _this44._requestToken({\n        grant_type: \"urn:ietf:params:oauth:grant-type:token-exchange\",\n        subject_token: e.subject_token,\n        subject_token_type: e.subject_token_type,\n        scope: F(e.scope, _this44.scope),\n        audience: e.audience || _this44.options.authorizationParams.audience\n      });\n    })();\n  }\n  _assertDpop(e) {\n    if (!e) throw new Error(\"`useDpop` option must be enabled before using DPoP.\");\n  }\n  getDpopNonce(e) {\n    return this._assertDpop(this.dpop), this.dpop.getNonce(e);\n  }\n  setDpopNonce(e, t) {\n    return this._assertDpop(this.dpop), this.dpop.setNonce(e, t);\n  }\n  generateDpopProof(e) {\n    return this._assertDpop(this.dpop), this.dpop.generateProof(e);\n  }\n  createFetcher(e = {}) {\n    if (this.options.useDpop && !e.dpopNonceId) throw new TypeError(\"When `useDpop` is enabled, `dpopNonceId` must be set when calling `createFetcher()`.\");\n    return new Se(e, {\n      isDpopEnabled: () => !!this.options.useDpop,\n      getAccessToken: e => {\n        var t;\n        return this.getTokenSilently({\n          authorizationParams: {\n            scope: null === (t = null == e ? void 0 : e.scope) || void 0 === t ? void 0 : t.join(\" \"),\n            audience: null == e ? void 0 : e.audience\n          }\n        });\n      },\n      getDpopNonce: () => this.getDpopNonce(e.dpopNonceId),\n      setDpopNonce: e => this.setDpopNonce(e),\n      generateDpopProof: e => this.generateDpopProof(e)\n    });\n  }\n}\nclass Oe {}\nfunction je(_x49) {\n  return _je.apply(this, arguments);\n}\nfunction _je() {\n  _je = _asyncToGenerator(function* (e) {\n    const t = new Pe(e);\n    return yield t.checkSession(), t;\n  });\n  return _je.apply(this, arguments);\n}\nexport { Pe as Auth0Client, h as AuthenticationError, M as CacheKey, u as GenericError, $ as InMemoryCache, Y as LocalStorageCache, m as MfaRequiredError, f as MissingRefreshTokenError, p as PopupCancelledError, l as PopupTimeoutError, d as TimeoutError, g as UseDpopNonceError, Oe as User, je as createAuth0Client };\n//# sourceMappingURL=auth0-spa-js.production.esm.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}